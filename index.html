<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <title>Skunk Fu - 2D Beat 'em Up</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêæ</text></svg>">
        <!-- Content Security Policy: configured via HTTP header for stronger enforcement. -->
        <!-- Server should set a header similar to:
            Content-Security-Policy: script-src 'self' 'nonce-<random>' https://static.cloudflareinsights.com; object-src 'none'; base-uri 'self';
            The server should also inject the matching nonce into the inline <script nonce="%CSP_NONCE%"> tags below.
        -->
    <link rel="stylesheet" href="styles.css">

    <style>
        /* expose safe-area insets as CSS variables so JS can read them */
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }
        /* INLINE STYLES FOR MOBILE OPTIMIZATION */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden; /* Prevent scroll */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* CRITICAL: Stops browser handling gestures */
            touch-action: none; 
        }

        /* Ensure canvas respects device safe areas (notches) */
        canvas {
            max-width: calc(100vw - var(--safe-left) - var(--safe-right));
            max-height: calc(100vh - var(--safe-top) - var(--safe-bottom));
            object-fit: contain;
            display: block;
        }

        /* --- TOUCH CONTROLS UI --- */
        #touch-controls {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let touches pass through empty areas */
            z-index: 100;
            display: none; /* Hidden by default, shown via JS if mobile */
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 220ms cubic-bezier(.2,.9,.2,1), transform 220ms cubic-bezier(.2,.9,.2,1);
        }

        #touch-controls.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .control-group {
            position: absolute;
            bottom: 20px;
            pointer-events: auto;
        }

        #d-pad { left: 20px; }
        #actions { right: 20px; }
        #game-over-controls { bottom: 100px; left: 50%; transform: translateX(-50%); }

        .touch-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            margin: 5px;
            user-select: none;
            outline: none;
            /* Disable browser touch actions */
            touch-action: none; 
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        /* --- OVERLAYS --- */
        #mobile-start-overlay, #rotate-message {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            color: white;
            font-family: sans-serif;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 240ms cubic-bezier(.2,.9,.2,1), transform 240ms cubic-bezier(.2,.9,.2,1);
        }

        #mobile-start-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #ff4d4d;
            border: none;
            color: white;
            border-radius: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        #mobile-start-overlay.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #mobile-restart-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #4dff4d;
            border: none;
            color: white;
            border-radius: 8px;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* --- ORIENTATION CHECK --- */
        #rotate-message { display: none; }
        
        @media screen and (orientation: portrait) {
            #rotate-message { display: flex; }
            #game-container { display: none; }
        }
    </style>
</head>
<body>

    <div id="rotate-message">
        <h1>Please Rotate Your Device</h1>
        <p>Landscape mode required</p>
    </div>

    <div id="game-container">
        <canvas id="game-canvas" width="1280" height="720"></canvas>
        
        <div id="loading-screen">
            <div class="loading-content">
                <h1>Skunk Fu</h1>
                <div class="loading-bar">
                    <div id="loading-progress" class="loading-progress"></div>
                </div>
                <p id="loading-text">Loading assets...</p>
            </div>
        </div>

        <!-- Touch controls moved out of #game-container to avoid transform/layout issues -->

        <div id="mobile-start-overlay" style="display:none;">
            <button id="mobile-start-btn">Tap to Start</button>
        </div>

        <!-- Error overlay (shown when runtime errors occur) -->
        <div id="error-overlay" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); color:#fff; z-index:4000; padding:20px; overflow:auto;">
            <h2 style="margin-bottom:8px;">Runtime Error</h2>
            <pre id="error-content" style="white-space:pre-wrap; font-size:13px; line-height:1.4;"></pre>
            <div style="margin-top:12px;">
                <button id="error-close" style="padding:8px 12px; margin-right:8px;">Close</button>
                <button id="error-copy" style="padding:8px 12px;">Copy</button>
            </div>
        </div>

        <!-- legacy mobile restart overlay removed; on-screen touch controls provide restart -->
    </div>

    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/spriteLoader.js"></script>
    <script src="js/audioManager.js"></script>
    <script src="js/visualEffects.js"></script>
    <script src="js/level.js"></script>
    <script src="js/player.js"></script>
    <script src="js/enemy.js"></script>
    <script src="js/enemyManager.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/game.js?v=6"></script>
    <script src="js/main.js"></script>

    <script nonce="%CSP_NONCE%">
// --- UTILITIES ---
    // Touch-control visibility debug helper
    window.touchDebug = window.touchDebug || [];
    function logTouchControlEvent(name, data) {
        try {
            const ts = Date.now();
            const entry = { ts, name, data };
            window.touchDebug.push(entry);
            // cap storage
            if (window.touchDebug.length > 200) window.touchDebug.shift();
            console.log('touchDebug:', name, data);
            // update on-screen badge if present
            const badge = document.getElementById('touch-debug-badge');
            if (badge && (location.search.indexOf('debugTouch=1') !== -1 || localStorage.getItem('debugTouch') === '1')) {
                badge.textContent = `${name} @ ${new Date(ts).toLocaleTimeString()}`;
                badge.style.display = 'block';
                badge.style.opacity = '1';
                setTimeout(() => { badge.style.opacity = '0.6'; }, 1200);
            }
        } catch (e) { console.warn('logTouchControlEvent failed', e); }
    }

    // Small on-screen badge (only visible when debugTouch enabled via URL or localStorage)
    ;(function(){
        const b = document.createElement('div');
        b.id = 'touch-debug-badge';
        b.style.position = 'fixed'; b.style.right = '8px'; b.style.top = '8px';
        b.style.padding = '6px 8px'; b.style.background = 'rgba(0,0,0,0.6)';
        b.style.color = '#0f0'; b.style.fontSize = '12px'; b.style.borderRadius = '6px';
        b.style.zIndex = 99999; b.style.display = 'none'; b.style.opacity = '0.6';
        document.body.appendChild(b);
    })();
function isMobile() {
    return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
}

function triggerKeyEvent(key, type) {
    // Normalize synthetic KeyboardEvent to provide both `key` and standard `code`.
    // Accept calls like triggerKeyEvent('ArrowLeft','keydown') or triggerKeyEvent('x','keydown').
    let k = key;
    let code = undefined;

    if (typeof key === 'string') {
        const lower = key.toLowerCase();
        if (lower === ' ' || lower === 'space' || lower === 'spacebar') {
            k = ' ';
            code = 'Space';
        } else if (/^arrow(left|right|up|down)$/i.test(key)) {
            // Arrow keys passed as 'ArrowLeft' etc.
            code = key;
            k = key;
        } else if (lower === 'enter') {
            k = 'Enter';
            code = 'Enter';
        } else if (lower === 'escape' || lower === 'esc') {
            k = 'Escape';
            code = 'Escape';
        } else if (lower === 'x') {
            k = 'x';
            code = 'KeyX';
        } else if (lower === 'z') {
            k = 'z';
            code = 'KeyZ';
        } else {
            // Default: use provided string for both fields
            code = key;
        }
    }

    const event = new KeyboardEvent(type, { key: k, code: code, bubbles: true, cancelable: true });
    window.dispatchEvent(event);
}

// Debounce helper for global UI handlers
function debounce(func, wait = 150) {
    let timeout = null;
    return function(...args) {
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// --- CONTROLS LOGIC ---
function initTouchControls() {
    if (!isMobile()) return;
    // If TouchControls class exists and no container is present, let it create and handle wiring.
    if (window.TouchControls && !document.getElementById('touch-controls')) {
        try {
            new TouchControls({ enabled: true, sensitivity: Config.TOUCH_UI.sensitivity });
        } catch (e) {
            if (typeof Config !== 'undefined' && Config.DEBUG) console.warn('TouchControls init failed', e);
        }
        return;
    }
    // Otherwise bind handlers to existing DOM buttons (static HTML fallback)

    const setupBtn = (id, key) => {
        const btn = document.getElementById(id);
        if(!btn) return;

        btn.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); return false; };

        const downHandler = (e) => {
            try { e && e.preventDefault(); } catch (_) {}
            triggerKeyEvent(key, 'keydown');
            if(key === ' ') triggerKeyEvent('ArrowUp', 'keydown');
            logTouchControlEvent('touch_down', { button: id, key });
        };
        const upHandler = (e) => {
            try { e && e.preventDefault(); } catch (_) {}
            triggerKeyEvent(key, 'keyup');
            if(key === ' ') triggerKeyEvent('ArrowUp', 'keyup');
            logTouchControlEvent('touch_up', { button: id, key });
        };

        btn.addEventListener('touchstart', downHandler, { passive: false });
        btn.addEventListener('touchend', upHandler, { passive: false });
        btn.addEventListener('pointerdown', downHandler);
        btn.addEventListener('pointerup', upHandler);
    };

    setupBtn('btn-left', 'ArrowLeft');
    setupBtn('btn-right', 'ArrowRight');
    setupBtn('btn-jump', ' ');
    setupBtn('btn-attack', 'x');
    setupBtn('btn-special', 'z');
    setupBtn('btn-pause', 'Escape');

    // Restart button handler
    const restartBtn = document.getElementById('btn-restart');
    if (restartBtn) {
        restartBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            triggerKeyEvent('Enter', 'keydown');
            setTimeout(() => triggerKeyEvent('Enter', 'keyup'), 100);
        }, { passive: false });
    }

    // Show/hide restart on game state
    window.addEventListener('gameStateChange', (e) => {
        if (restartBtn && e.detail.state === 'GAME_OVER') {
            restartBtn.style.display = 'block';
        } else if (restartBtn) {
            restartBtn.style.display = 'none';
        }
    });
}

// --- MOBILE START & FULLSCREEN ---
const mobileStartOverlay = document.getElementById('mobile-start-overlay');
const mobileStartBtn = document.getElementById('mobile-start-btn');
const mobileRestartOverlay = document.getElementById('mobile-restart-overlay');

function showMobileStartOverlay() {
    if (!mobileStartOverlay) return;
    if (getComputedStyle(mobileStartOverlay).display === 'none') mobileStartOverlay.style.display = 'flex';
    // trigger transition
    void mobileStartOverlay.offsetWidth;
    mobileStartOverlay.classList.add('visible');
}
function hideMobileStartOverlay() {
    if (!mobileStartOverlay) return;
    mobileStartOverlay.classList.remove('visible');
    // Use transitionend to hide after animation, but add a timeout fallback
    let cleared = false;
    const onEnd = (ev) => {
        if (ev && ev.target !== mobileStartOverlay) return;
        if (cleared) return;
        cleared = true;
        mobileStartOverlay.style.display = 'none';
        mobileStartOverlay.removeEventListener('transitionend', onEnd);
        if (timeoutId) clearTimeout(timeoutId);
    };
    mobileStartOverlay.addEventListener('transitionend', onEnd);
    // Fallback: ensure element is hidden after transition duration + buffer (240ms + 120ms)
    const timeoutId = setTimeout(() => {
        if (cleared) return;
        cleared = true;
        mobileStartOverlay.style.display = 'none';
        mobileStartOverlay.removeEventListener('transitionend', onEnd);
    }, 400);
}

function showMobileRestartOverlay() {
    if (mobileRestartOverlay) mobileRestartOverlay.style.display = 'flex';
}
function hideMobileRestartOverlay() {
    if (mobileRestartOverlay) mobileRestartOverlay.style.display = 'none';
}

function requestFullscreen() {
    const docEl = document.documentElement;
    const requestMethod = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen;
    if (requestMethod) {
        requestMethod.call(docEl).catch(err => {
            // Silently fail if user denies or browser blocks
            console.log("Fullscreen request denied:", err);
        });
    }
}

if (isMobile() && mobileStartBtn) {
    showMobileStartOverlay();
    const startHandler = (e) => {
        try { e && e.preventDefault(); } catch (_) {}

        const proceed = () => {
            // Enter Fullscreen and start the game in the same user gesture
            requestFullscreen();
            triggerKeyEvent('Enter', 'keydown');
            setTimeout(() => triggerKeyEvent('Enter', 'keyup'), 100);
            hideMobileStartOverlay();
        };

        if (window.gameReady) {
            proceed();
        } else {
            // Indicate loading and wait for the gameReady event
            mobileStartBtn.disabled = true;
            const prevText = mobileStartBtn.textContent;
            mobileStartBtn.textContent = 'Loading...';
            const onReady = () => {
                mobileStartBtn.disabled = false;
                mobileStartBtn.textContent = prevText;
                window.removeEventListener('gameReady', onReady);
                proceed();
            };
            window.addEventListener('gameReady', onReady);
        }
    };

    mobileStartBtn.addEventListener('pointerup', startHandler, { passive: false });
    mobileStartBtn.addEventListener('click', (e) => startHandler(e));

    // Re-show overlay if game goes back to Menu
    window.addEventListener('gameStateChange', function(e) {
        if (e.detail && e.detail.state === 'MENU') {
            showMobileStartOverlay();
        } else {
            hideMobileStartOverlay();
        }
    });
}

// --- ORIENTATION & MOBILE UI HANDLING ---
function isLandscape() {
    return window.matchMedia && window.matchMedia('(orientation: landscape)').matches || window.innerWidth > window.innerHeight;
}

function updateMobileUI() {
    if (!isMobile()) return;

    if (!isLandscape()) {
        // Portrait: force rotate message, hide controls and start overlay
        const rotate = document.getElementById('rotate-message');
        if (rotate) rotate.style.display = 'flex';
        hideMobileStartOverlay();
        hideMobileRestartOverlay();
        const tc = document.getElementById('touch-controls');
        if (tc) tc.style.display = 'none';
    } else {
        // Landscape: allow overlays if appropriate
        const rotate = document.getElementById('rotate-message');
        if (rotate) rotate.style.display = 'none';
        // Only show start overlay when game is in MENU and ready
        if (window.gameReady && window.game && window.game.state === 'MENU') {
            showMobileStartOverlay();
        }
        const tc = document.getElementById('touch-controls');
        // Ensure controls exist and have listeners, but keep them hidden until gameplay starts
        if (tc) {
            tc.style.display = 'none';
            initTouchControls();
        }
    }
}

const debouncedUpdateMobileUI = debounce(updateMobileUI, 180);
window.addEventListener('orientationchange', debouncedUpdateMobileUI);
window.addEventListener('resize', debouncedUpdateMobileUI);
// Ensure fullscreen transitions also update mobile UI and re-show controls when appropriate
document.addEventListener('fullscreenchange', () => {
    // Let the browser stabilize then re-evaluate UI
    setTimeout(() => debouncedUpdateMobileUI(), 150);
    // If the game is playing after entering fullscreen, force-show controls
    setTimeout(() => {
        const tc = document.getElementById('touch-controls');
        if (!tc) return;
        if (window.game && window.game.state === 'PLAYING' && isMobile() && isLandscape()) {
            tc.style.display = 'flex'; tc.style.pointerEvents = 'auto'; void tc.offsetWidth; tc.classList.add('visible');
        }
    }, 200);
});
// run once on load (use non-debounced immediate call so layout is correct)
updateMobileUI();

// Show/hide touch controls based on game state: only visible during PLAYING on mobile landscape
window.addEventListener('gameStateChange', function(e) {
    const tc = document.getElementById('touch-controls');
    if (!tc) return;
    if (!isMobile()) { tc.style.display = 'none'; tc.style.pointerEvents = 'none'; return; }
    if (!isLandscape()) { tc.style.display = 'none'; tc.style.pointerEvents = 'none'; return; }
    if (e && e.detail && e.detail.state === 'PLAYING') {
        // show with animation
        if (tc.style.display === 'none' || getComputedStyle(tc).display === 'none') tc.style.display = 'flex';
        // enable pointer events so buttons are interactive
        tc.style.pointerEvents = 'auto';
        // force reflow then add visible class to trigger transition
        void tc.offsetWidth;
        tc.classList.add('visible');
        // guard against other listeners overriding display by re-applying after animation
        setTimeout(() => {
            if (getComputedStyle(tc).display !== 'flex') tc.style.display = 'flex';
            if (!tc.classList.contains('visible')) tc.classList.add('visible');
            tc.style.pointerEvents = 'auto';
        }, 120);
    } else {
        // hide with animation
        tc.classList.remove('visible');
        // disable pointer events immediately to avoid ephemeral input
        tc.style.pointerEvents = 'none';
        // after transition, set display:none to remove from layout
        const onEnd = (ev) => {
            if (ev && ev.target !== tc) return;
            tc.style.display = 'none';
            tc.removeEventListener('transitionend', onEnd);
        };
        tc.addEventListener('transitionend', onEnd);
    }
});

// --- RUNTIME ERROR CAPTURE ---
(function () {
    const overlay = document.getElementById('error-overlay');
    const content = document.getElementById('error-content');
    const closeBtn = document.getElementById('error-close');
    const copyBtn = document.getElementById('error-copy');

    function showError(msg) {
        if (!overlay || !content) return;
        content.textContent = msg;
        overlay.style.display = 'block';
    }

    if (closeBtn) closeBtn.addEventListener('click', () => { overlay.style.display = 'none'; });
    if (copyBtn) copyBtn.addEventListener('click', () => { if (navigator.clipboard) navigator.clipboard.writeText(content.textContent || ''); });

    window.addEventListener('error', (e) => {
        const msg = `${e.message} at ${e.filename}:${e.lineno}:${e.colno}\n${e.error && e.error.stack ? e.error.stack : ''}`;
        console.error('Captured error:', msg);
        showError(msg);
    });

    window.addEventListener('unhandledrejection', (ev) => {
        const reason = ev.reason ? (ev.reason.stack || ev.reason) : 'Unknown';
        const msg = `Unhandled Rejection: ${reason}`;
        console.error(msg);
        showError(msg);
    });
})();

/* Re-insert touch controls as a fixed overlay so transforms on #game-container don't affect layout */
(function() {
    const html = `
    <div id="touch-controls" style="position:fixed; bottom:calc(20px + var(--safe-bottom)); left:0; right:0; transform:none; display:none; justify-content:space-between; align-items:flex-end; pointer-events:none; z-index:2000; padding:0 calc(20px + var(--safe-right));">
        <div id="d-pad" class="control-group" style="pointer-events:auto; display:flex; gap:8px;">
            <button class="touch-btn" id="btn-left">&#8592;</button>
            <button class="touch-btn" id="btn-right">&#8594;</button>
        </div>
        <div id="game-over-controls" class="control-group" style="pointer-events:auto; display:flex; gap:8px;">
            <button class="touch-btn" id="btn-restart" style="display:none;">Restart</button>
        </div>
        <div id="actions" class="control-group" style="pointer-events:auto; display:flex; gap:8px;">
            <button class="touch-btn" id="btn-attack" style="background: rgba(255, 50, 50, 0.3);">Attack</button>
            <button class="touch-btn" id="btn-special" style="background: rgba(255, 100, 255, 0.3);">Special</button>
            <button class="touch-btn" id="btn-jump">&#8593;</button>
            <button class="touch-btn" id="btn-pause">Pause</button>
        </div>
    </div>
    `;
    document.body.insertAdjacentHTML('beforeend', html);
    // Ensure touch control handlers are bound now that elements exist
    if (typeof initTouchControls === 'function') initTouchControls();
})();

/* --- DEBUG OVERLAY (toggle with 'd') --- */
(function() {
    const css = `
    #debug-overlay { position: fixed; right: 12px; top: 12px; background: rgba(0,0,0,0.7); color: #0f0; font-family: monospace; font-size:12px; padding:8px 10px; border-radius:6px; z-index:9999; display:none; pointer-events:none; max-width:260px; }
    #debug-overlay b { color: #fff; }
    `;
    const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);

    const overlay = document.createElement('div');
    overlay.id = 'debug-overlay';
    overlay.innerHTML = '<div><b>Debug</b></div><div id="dbg-info"></div>';
    document.body.appendChild(overlay);

    const info = overlay.querySelector('#dbg-info');
    const canvas = document.getElementById('game-canvas');
    function fmt(n) { return (n===undefined || n===null) ? '-' : n; }

    function readSafe(name) {
        const v = getComputedStyle(document.documentElement).getPropertyValue('--safe-' + name) || '0px';
        return parseFloat(v) || 0;
    }

    let rafId = null;
    function render() {
        const cs = getComputedStyle(canvas);
        const cssW = cs.width;
        const cssH = cs.height;
        const intW = canvas.width;
        const intH = canvas.height;
        const dpr = window.devicePixelRatio || 1;
        const safeTop = readSafe('top');
        const safeBottom = readSafe('bottom');
        const safeLeft = readSafe('left');
        const safeRight = readSafe('right');

        info.innerHTML = `CSS: ${cssW} √ó ${cssH}<br>Internal: ${intW} √ó ${intH}<br>DPR: ${dpr}<br>SafeInsets: top ${safeTop}px bottom ${safeBottom}px left ${safeLeft}px right ${safeRight}px`;
        rafId = requestAnimationFrame(render);
    }

    function show() {
        overlay.style.display = 'block';
        if (!rafId) render();
    }
    function hide() {
        overlay.style.display = 'none';
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    }

    // toggle with `d`
    window.addEventListener('keydown', (e) => {
        if (e.key && e.key.toLowerCase() === 'd') {
            if (overlay.style.display === 'none' || overlay.style.display === '') show(); else hide();
        }
    });

    // Update overlay after debounced UI updates
    const deb = debounce(() => {
        if (overlay.style.display !== 'none') {
            // force one immediate re-render
            if (rafId) cancelAnimationFrame(rafId);
            render();
        }
    }, 200);
    window.addEventListener('resize', deb);
    window.addEventListener('orientationchange', deb);
})();
</script>
</body>
</html>